#!/usr/bin/env bash

set -e
set -o pipefail

VAULT_ADDRESS_OPTION=vault.address
VAULT_ROLE_ID_OPTION=vault.role_id.value
VAULT_WRAPPED_SECRET_ID_FILE_PATH_OPTION=vault.secret_id.wrapped.file_path
VAULT_UNWRAPPED_SECRET_ID_FILE_PATH_OPTION=vault.secret_id.unwrapped.file_path

VAULT_UNWRAP_ENGINE_OPTION=vault.secret_id.unwrap.engine_type
VAULT_UNWRAP_FIELD_OPTION=vault.secret_id.unwrap.field
VAULT_UNWRAP_CACERT_OPTION=vault.secret_id.unwrap.cacert
VAULT_UNWRAP_CAPATH_OPTION=vault.secret_id.unwrap.capath

VAULT_UNWRAP_URL='sys/wrapping/unwrap'

#
# check if required utils are installed
#
vault_ensure_utils() {
  ensure_command jq || return 1
  ensure_command curl || return 1
}

#
# return 1 if something configured incorrectly
#
vault_ensure_required() {
  local wrapped_secret_id_file_path unwrapped_secret_id_file_path

  ensure_option_present "${VAULT_ADDRESS_OPTION}" REQUIRED
  vault_ensure_utils || return 1
  ensure_option_present "${VAULT_ROLE_ID_OPTION}" REQUIRED
  ensure_option_present "${VAULT_UNWRAPPED_SECRET_ID_FILE_PATH_OPTION}" REQUIRED

  if ensure_option_present "${VAULT_WRAPPED_SECRET_ID_FILE_PATH_OPTION}" OPTIONAL; then
    wrapped_secret_id_file_path=$(find_in_configs_or_empty "${VAULT_WRAPPED_SECRET_ID_FILE_PATH_OPTION}")
    ensure_file_exists "${wrapped_secret_id_file_path}" || return 1
  else
    print_level_message 1 INFO "No '${VAULT_WRAPPED_SECRET_ID_FILE_PATH_OPTION}'. Expecting unwrapped secret file exists..."
    unwrapped_secret_id_file_path=$(find_in_configs_or_empty "${VAULT_UNWRAPPED_SECRET_ID_FILE_PATH_OPTION}")
    ensure_file_exists "${unwrapped_secret_id_file_path}" || return 1
    return 0
  fi
}

#
# return 1 if no need to unwrap approle's secret_id
# exit 1 if some required options not met
#
vault_ensure_unwrap_required() {
  local wrapped_secret_id_file_path

  ensure_option_present "${VAULT_ADDRESS_OPTION}" REQUIRED
  vault_ensure_utils || return 1
  ensure_option_present "${VAULT_ROLE_ID_OPTION}" REQUIRED
  ensure_option_present "${VAULT_UNWRAPPED_SECRET_ID_FILE_PATH_OPTION}" REQUIRED
  ensure_option_present "${VAULT_WRAPPED_SECRET_ID_FILE_PATH_OPTION}" REQUIRED
  wrapped_secret_id_file_path=$(find_in_configs_or_empty "${VAULT_WRAPPED_SECRET_ID_FILE_PATH_OPTION}")
  ensure_file_exists "${wrapped_secret_id_file_path}" || return 1
}

#
# check if configured to unwrap secret.
# For using in start script
#
vault_unwrap_configured() {
  have_in_configs "${VAULT_ADDRESS_OPTION}" || return 1
  have_in_configs "${VAULT_WRAPPED_SECRET_ID_FILE_PATH_OPTION}" || return 1
  have_in_configs "${VAULT_UNWRAPPED_SECRET_ID_FILE_PATH_OPTION}" || return 1
}

#
# unwrap vault secret_id
# example: curl -X PUT -H "X-Vault-Request: true" -H "X-Vault-Token: $(vault print token)" -d 'null' http://127.0.0.1:8200/v1/sys/wrapping/unwrap
#
vault_unwrap_make_request() {
  local base_url=$1; shift;
  local vault_wrapped_secret=$1; shift;
  local cacert_path=$1; shift;
  local cadir_path=$1; shift;

  local curl_args url output_file http_code

  curl_args=(--request PUT)
  curl_args+=(--header "X-Vault-Request: true")

  curl_args+=(--header "X-Vault-Token: ${vault_wrapped_secret}")

  if [ -n "${cacert_path}" ]; then
    curl_args+=(--cacert "${cacert_path}")
  fi

  if [ -n "${cadir_path}" ]; then
    curl_args+=(--capath "${cadir_path}")
  fi

  url="${base_url}/v1/${VAULT_UNWRAP_URL}"

  output_file=$(mktemp)

  # shellcheck disable=SC2086
  http_code=$(curl --silent "${curl_args[@]}" "${url}" --output "${output_file}" --write-out "%{http_code}")

  if [[ ${http_code} -lt 200 || ${http_code} -gt 299 ]]; then
    print_level_message 2 ERROR "Got http code: ${http_code} from Vault server: '${base_url}'"
    cat >&2 "${output_file}"
    rm "${output_file}"
    return 22
  fi
  cat "${output_file}"
  rm "${output_file}"
}

#
# to unwrap secret_id approle, kv-v1 and kv-v2 supported
#
vault_check_unwrap_secret_engine_type() {
  if [ "${engine_type}" == "approle" ]; then
    return 0
  elif [ "${engine_type}" == "kv-v1" ]; then
    return 0
  elif [ "${engine_type}" == "kv-v2" ]; then
    return 0
  else
    print_level_message 2 ERROR "Unsupported engine_type: ${engine_type}"
    return 1
  fi
}

#
# JQ filter to get unwrapped value from the `vault unwrap`
#
vault_unwrap_result_jq_filter() {
  local engine_type=$1; shift;
  local field_name=$1; shift;

  local jq_filter
  if [ "${engine_type}" == "kv-v1" ] || [ "${engine_type}" == "approle" ]; then
    jq_filter=".data"
  elif [ "${engine_type}" == "kv-v2" ]; then
    jq_filter=".data.data"
  else
    print_level_message 2 ERROR "Unsupported engine_type: ${engine_type}"
    return 1
  fi

  if [ -n "${field_name}" ]; then
    jq_filter="${jq_filter}.${field_name}"
  else
    jq_filter="${jq_filter}"'[]'
  fi

  echo "${jq_filter}"
}

#
# print error message that can not correctly parse result from vault
#
vault_invalid_engine_or_field_message() {
  local engine_type=$1; shift;
  local field_name=$1; shift;
  local jq_filter=$1; shift;
  local tmp_src=$1; shift;

  print_level_message 2 ERROR "Not found expected result in field: '${jq_filter}'."
  cat >&2 << EOL
Is engine type: '${engine_type}' (property '${VAULT_UNWRAP_ENGINE_OPTION}')
and/or field name: '${field_name}' (property '${VAULT_UNWRAP_FIELD_OPTION}') are correct?
EOL
  echo >&2 "Got from vault server: "
  cat "${tmp_src}" >&2
  echo "" >&2
  rm "${tmp_src}"
}

#
# unwrap value from the `vault unwrap` with jq
#
vault_parse_unwrap_result() {
  local engine_type=$1; shift;
  local field_name=$1; shift;

  local jq_filter jq_result jq_raw_result tmp_src

  jq_filter=$(vault_unwrap_result_jq_filter "${engine_type}" "${field_name}")

  tmp_src=$(mktemp)
  cat > "${tmp_src}"
  if [ ! -s "${tmp_src}" ]; then
    print_level_message 2 ERROR "No vault server response found"
    rm "${tmp_src}"
    return 1
  fi

  jq_result=$(jq "${jq_filter}" < "${tmp_src}" || true )
  jq_result_type=$(echo "${jq_result}" | jq -r 'type')
  if [ "${jq_result_type}" != string ]; then
    vault_invalid_engine_or_field_message "${engine_type}" "${field_name}" "${jq_filter}" "${tmp_src}"
    return 1
  fi

  jq_raw_result=$(jq -r "${jq_filter}" < "${tmp_src}" || true )

  rm "${tmp_src}"
  echo "${jq_raw_result}"
}

#
# when need to unwrap secret_id?
# * no unwrapped file present or it empty
# * wrapped file newer then wrapped file
# * force unwrap option provided
vault_is_need_unwrap() {
  local wrapped_secret_file=$1; shift;
  local unwrapped_secret_file=$1; shift;
  local force_option=$1

  # if unwrapped file exists then compare by timestamp
  if [ ! -s "${unwrapped_secret_file}" ]; then
    return 0
  fi

  if [ "${wrapped_secret_file}" -nt "${unwrapped_secret_file}" ]; then
    return 0
  fi

  if [ "${force_option}" == 1 ]; then
    return 0
  fi

  return 1
}

#
# actually make unwrap:
# just run curl and filter it output with jq
#
make_unwrap() {
  local wrapped_secret_file=$1; shift;
  local unwrapped_secret_file=$1; shift;

  local vault_wrapped_secret unwrapped_secret_dir

  vault_wrapped_secret=$(xargs < "${wrapped_secret_file}" || return 1)
  if [ -z "${vault_wrapped_secret}" ]; then
    print_level_message 2 ERROR "Failed to read data from ${wrapped_secret_file}."
    return 1
  fi

  unwrapped_secret_dir=$(dirname "${unwrapped_secret_file}")
  mkdir -p "${unwrapped_secret_dir}"
  chmod 755 "${unwrapped_secret_dir}"

  local base_url engine_type field_name default_field_name cacert_path cadir_path

  base_url=$(find_in_configs_or_empty "${VAULT_ADDRESS_OPTION}")
  engine_type=$(find_in_configs_or_empty "${VAULT_UNWRAP_ENGINE_OPTION}" kv-v2)
  vault_check_unwrap_secret_engine_type "${engine_type}" || return 1

  if [ "${engine_type}" == approle ]; then
    default_field_name='secret_id'
  fi
  field_name=$(find_in_configs_or_empty "${VAULT_UNWRAP_FIELD_OPTION}" "${default_field_name}")

  cacert_path=$(find_in_configs_or_empty "${VAULT_UNWRAP_CACERT_OPTION}")
  if [ -n "${cacert_path}" ] && [ ! -s "${cacert_path}" ]; then
    print_level_message 2 ERROR "File '${cacert_path}' ('${VAULT_UNWRAP_CACERT_OPTION}') not found"
    return 1
  fi

  cadir_path=$(find_in_configs_or_empty "${VAULT_UNWRAP_CAPATH_OPTION}")
  if [ -n "${cadir_path}" ] && [ ! -d "${cadir_path}" ]; then
    print_level_message 2 ERROR "Directory '${cadir_path}' ('${VAULT_UNWRAP_CAPATH_OPTION}') not found"
    return 1
  fi

  touch "${unwrapped_secret_file}"
  truncate -s 0 "${unwrapped_secret_file}"
  chmod 644 "${unwrapped_secret_file}"
  vault_unwrap_make_request \
      "${base_url}" \
      "${vault_wrapped_secret}" \
      "${cacert_path}" \
      "${cadir_path}" \
    | vault_parse_unwrap_result \
      "${engine_type}" \
      "${field_name}" \
    >> "${unwrapped_secret_file}"
}

vault_unwrap_secret() {
  local force_option=$1

  if ! vault_ensure_unwrap_required; then
    return 0
  fi

  local unwrapped_secret_file wrapped_secret_file

  wrapped_secret_file=$(find_in_configs_or_empty "${VAULT_WRAPPED_SECRET_ID_FILE_PATH_OPTION}")
  unwrapped_secret_file=$(find_in_configs_or_empty "${VAULT_UNWRAPPED_SECRET_ID_FILE_PATH_OPTION}")

  if ! vault_is_need_unwrap "${wrapped_secret_file}" "${unwrapped_secret_file}" "${force_option}"; then
    print_level_message 1 INFO "Unwrapped secret exists and newer then wrapped. So looks like no need to unwrap. Use option 'force' for unwrap anyway."
    return 0
  fi

  run_long_task_with_log make_unwrap "Unwrap approle secret" "${wrapped_secret_file}" "${unwrapped_secret_file}"
}
