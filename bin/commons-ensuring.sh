#!/usr/bin/env bash

##
## Ensure ... module. Ensure presents (exists/works/enough) some required thins:
## * required option in config
## * program (such a docker, awk etc)
## * docker compose plugin/docker-compose standalone
## * docker CPU cores/arch/memory
##

#
# Ensure if option is present in the config and display it to the user.
# if option not found:
# * print error and fail script with `exit 1` if options is required
# * print warning and fail function with `return 2` if options is not required
# * print fatal and fail with `exit 3` if unknown requirement_level
# args:
# * `option_name`: option to find
# * `requirement_level`: REQUIRED or OPTIONAL
#
ensure_option_present() {
  local option_name=$1; shift;
  local requirement_level=$1; shift;

  echo -n "check option '${option_name}': "

  local option_value
  option_value=$(find_in_configs_or_empty "${option_name}")

  if [ -z "${option_value}" ]; then
    if [ "${requirement_level}" == REQUIRED ]; then
      print_level_message 1 ERROR "FAILED"
      print_level_message 2 ERROR "Required option '${option_name}' is not found. Exit."
      exit 1
    elif [ "${requirement_level}" == OPTIONAL ]; then
      print_level_message 1 WARNING "FAILED"
      print_level_message 1 WARNING "Option '${option_name}' is not found."
      return 2
    else
      print_level_message 2 FATAL "Unknown requirement level: ${requirement_level}"
      exit 3
    fi
  fi

  echo -n "'${option_value}': "
  print_level_message 1 SUCCESS "OK"
}

#
# Ensure command exists and display info it to user
# Future improvements:
# * add `requirement_level` similar to `ensure_option_present`
#
ensure_command() {
  local command=$1

  local command_path
  echo -n "check '${command}': "
  command_path=$(command -v "${command}" || true)
  if [ -z "${command_path}" ] ; then
    print_level_message 1 ERROR "FAILED"
    print_level_message 2 ERROR "Required '${command}' is not found. Exit."
    exit 1
  fi
  echo -n "'${command_path}': "
  print_level_message 1 SUCCESS "OK"
}

#
# Ensure docker compose or docker-compose exists and runnable
# display info to user
#
ensure_docker_compose() {
  local docker_executable=$1; shift;
  local compose_standalone_executable=$1; shift;

  local docker_compose_version

  # check if docker compose plugin works OK
  echo -n "check '${docker_executable} compose': "
  if "${docker_executable}" compose version > /dev/null 2>/dev/null; then
    docker_compose_version=$(${docker_executable} compose version)
    echo -n "${docker_compose_version}: "
    print_level_message 1 SUCCESS "OK"
    return 0
  fi
  print_level_message 1 WARNING "Not found"

  # if docker compose plugin doesn't exists try to find docker-compose standalone

  # check if docker-compose standalone exists
  echo -n "check '${compose_standalone_executable}': "
  local docker_compose_cmd
  docker_compose_cmd=$(command -v "${compose_standalone_executable}" || true)
  if [ -z "${docker_compose_cmd}" ]; then
    print_level_message 1 ERROR "FAIL"
    print_level_message 2 ERROR \
      "Neither ${docker_executable} compose nor ${compose_standalone_executable} was found. Please check if it is installed. Exit."
    exit 1
  fi

  # check if docker-compose standalone works OK
  if ! "${docker_compose_cmd}" --version >/dev/null 2>/dev/null; then
    print_level_message 1 ERROR "FAIL"
    print_level_message 2 ERROR \
      "${docker_compose_cmd} found but fail to run. Please check if it is executable. Exit."
    exit 1
  fi
  docker_compose_version=$("${docker_compose_cmd}" --version)
  echo -n "${docker_compose_cmd} (${docker_compose_version}): "
  print_level_message 1 SUCCESS "OK"
}

#
# Ensure CPU core amount is enough
# display info to user
#
ensure_docker_cpu() {
  local docker_executable=$1; shift;
  local cpu_req=$1; shift;

  echo -n "check CPU: "
  local cpu_arch cpu_amount
  cpu_arch=$(${docker_executable} info --format '{{.Architecture}}')
  cpu_amount=$(${docker_executable} info --format '{{.NCPU}}')
  echo -n "${cpu_amount} cores of ${cpu_arch} architecture: "

  if [ "${cpu_arch}" != 'x86_64' ]; then
    print_level_message 1 ERROR "FAIL"
    print_level_message 2 ERROR "Currently, only the x86_64 CPU architecture is supported. Exit."
    exit 1
  fi

  if [ "${cpu_amount}" -lt "${cpu_req}" ]; then
    print_level_message 1 ERROR "FAIL"
    print_level_message 2 ERROR "At least ${cpu_req} CPU cores are required. Exit."
    exit 1
  fi

  print_level_message 1 SUCCESS "OK"
}

#
# Ensure RAM amount is enough
# display it to user
#
ensure_docker_mem() {
  local docker_executable=$1; shift;
  local mem_req_mb=$1; shift;

  echo -n "check RAM: "
  local free_memory free_memory_mb
  free_memory=$(${docker_executable} info --format '{{.MemTotal}}')
  free_memory_mb=$(( free_memory / 1024 / 1024))
  echo -n "${free_memory_mb} MiB: "
  if [ "${free_memory_mb}" -lt "${mem_req_mb}" ]; then
    print_level_message 1 ERROR "FAIL"
    print_level_message 2 ERROR "At least ${mem_req_mb} MiB memory is required. Exit."
    exit 1
  fi
  print_level_message 1 SUCCESS "OK"
}

#
# Ensure if file exist  and display it to the user.
# if not found option:
# * fail script with `exit 1`]`
# args:
# * `filepath`: file to find
#
ensure_file_exists() {
  local filepath=$1; shift;
  echo -n "check file exists '${filepath}': "

  if [ ! -f "${filepath}" ] ; then
    print_level_message 1 ERROR "FAILED"
    print_level_message 2 ERROR "Required file '${filepath}' is not found. Exit."
    exit 1
  fi
  echo -n "'${filepath}': "
  print_level_message 1 SUCCESS "OK"
}
