#!/usr/bin/env bash

COMMAND="${1}"
shift

set -e

if [ -n "${HW_BW_BASE_DIR}" ]; then
  if [ -f "${HW_BW_BASE_DIR}/bin/common-functions.sh" ]; then
    . "${HW_BW_BASE_DIR}/bin/common-functions.sh"
  else
    log_message 2 FATAL "${HW_BW_BASE_DIR}/bin/common-functions.sh not found"
    exit 1
  fi
elif [ -f "${PWD}/bin/common-functions.sh" ]; then
  . "${PWD}/bin/common-functions.sh"
  HW_BW_BASE_DIR="${PWD}"
else
  SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
  if [ -f "${SCRIPT_DIR}/bin/common-functions.sh" ]; then
    . "${SCRIPT_DIR}/bin/common-functions.sh"
    HW_BW_BASE_DIR="${SCRIPT_DIR}"
  else
    log_message 2 FATAL "common-functions.sh not found"
    exit 1
  fi
fi

#
# print usage info (help)
#
usage() {
  echo "Usage:"
  echo "${BASH_SOURCE[0]} <command> [args]"
  echo "Commands:"
  echo "* 'check': check if can run."
  echo "* 'config', 'reconfig': configure application before start & reconfigure after update."
  echo "* 'run': run application interactively (logs in console)."
  echo "* 'start' start application detached and wait while ready."
  echo "* 'stop' stop application."
  echo "* 'get-config-value' get config value."
  echo "Notes:"
  echo "* config performed automatically on first run."
  echo "* need to run config/reconfig after application update."
  echo "* need to run config/reconfig after any changes in 'config/user.ini'."
  echo "* if you start the application using the 'run' command, you will not"
  echo "  get default 'root@ro.ot' user password in the console. "
  echo "  But you may get it with command '${BASH_SOURCE[0]} get-config-value b.root.password'"
}

#
# Print error message, print usage and exit
# args:
# * error_message: message to print
#
error_usage_exit() {
  local error_message=$1
  print_level_message 2 ERROR "${error_message}"
  usage >&2
  exit 1
}

#
# show ascii logo file if exists
#
show_logo() {
  if [ -f "${HW_BW_BASE_DIR}/ascii-logo.txt" ]; then
    cat "${HW_BW_BASE_DIR}/ascii-logo.txt"
  fi
}

#
# Run any long task and log BEGIN and FINISH or FAILED
#
run_long_task_with_log() {
  local run_cmd=$1; shift;
  local message=$1; shift;

  print_level_message 2 INFO "BEGIN ${message}"
  local cmd_exit_usage
  "${run_cmd}" "$@"
  cmd_exit_usage="$?"
  if [ "${cmd_exit_usage}" == 0 ]; then
    print_level_message 2 SUCCESS "FINISH ${message}"
  elif [ "${cmd_exit_usage}" == 130 ]; then
    # By Ctrl+C we got 2 (SIGINT) + 128 = 130
    print_level_message 2 SUCCESS "STOPPED ${message}"
  else
    print_level_message 2 ERROR "FAILED ${message}"
  fi
}

#
# load images attached to fat bundles
#
load_images() {
  if [ -f load-images.sh ]; then
    echo "Load docker images..."
    if ! bash -e load-images.sh; then
      fail_installation "Can not load images"
    fi
    echo "... DONE"
  fi
}

app_check() {
  show_logo
  check_prereq "${MIN_CPU}" "${MIN_RAM}"
}

#
# config application
#
app_reconfig() {
  show_logo
  load_images
  check_prereq "${MIN_CPU}" "${MIN_RAM}"
  make_reconfig
}

#
# start application
#
app_start() {
  show_logo
  check_prereq "${MIN_CPU}" "${MIN_RAM}"
  if ! is_configured; then
    load_images
    run_long_task_with_log make_reconfig "config application" || return 1
  fi

  run_docker_compose up --detach
  service_await_and_welcome
}

#
# stop application
#
app_stop() {
  if ! is_configured; then
    print_level_message 2 ERROR "Application not configure yet so nothing to stop."
    return 1
  fi
  run_docker_compose down
}

#
# run application
#
app_run() {
  show_logo
  check_prereq "${MIN_CPU}" "${MIN_RAM}"
  if ! is_configured; then
    load_images
    run_long_task_with_log make_reconfig "config application" || return 1
  fi

  run_docker_compose up
}

#
# get config value
#
app_get_config_value() {
  local property_key=$1
  local property_value
  property_value=$(find_in_configs "${property_key}")
  if [ "${property_value}" = "<unknown>" ]; then
    echo >&2 "config property '${property_key}' not found"
    exit 1
  fi
  echo "${property_value}"
}

#
# run command supported
#
run_command() {
  local command=$1; shift;

  case "${command}" in
  help|--help)
    usage
    ;;
  check)
    app_check "$@"
    ;;
  config|reconfig)
    run_long_task_with_log app_reconfig "config application" "$@"
    ;;
  start)
    run_long_task_with_log app_start "start application detached" "$@"
    ;;
  stop)
    run_long_task_with_log app_stop "stop application" "$@"
    ;;
  run)
    run_long_task_with_log app_run "run application interactively" "$@"
    ;;
  get-config-value)
    app_get_config_value "$@"
    ;;
  *)
    error_usage_exit "Unknown command: ${command}"
    ;;
  esac
}

if [ -z "${COMMAND}" ]; then
  error_usage_exit "No command provided"
fi

run_command "${COMMAND}" "$@"
